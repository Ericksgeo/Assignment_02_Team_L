class ShortestPath:

    def __init__(self, itn_filepath, ele_array, ele_info):
        self.__filepath = itn_filepath
        self.__ele_array = ele_array
        self.__ele_ncols = ele_info[0]
        self.__ele_nrows = ele_info[1]
        self.__ele_xllcorner = ele_info[2]
        self.__ele_yllcorner = ele_info[3]
        self.__ele_cell = ele_info[4]

    def get_path(self, start, end):
        self.__start = start
        self.__end = end
        # create the graph from the dictionary loaded from the JSON file
        solent_itn_json = self.__filepath
        with open(solent_itn_json, "r") as f:
            solent_itn = json.load(f)
        g = nx.DiGraph()
        road_links = solent_itn['roadlinks']
        road_nodes = solent_itn['roadnodes']

        for link in road_links:
            point_a_id = road_links[link]['start']
            point_b_id = road_links[link]['end']
            # get coordinates of start point and end point of each road
            for node in road_nodes:
                if node == point_a_id:
                    point_a_x = road_nodes[node]['coords'][0]
                    point_a_y = road_nodes[node]['coords'][1]
                elif node == point_b_id:
                    point_b_x = road_nodes[node]['coords'][0]
                    point_b_y = road_nodes[node]['coords'][1]

            # get the start point raster and end point raster
            point_a_r = (self.__ele_nrows - (point_a_y - self.__ele_yllcorner) // self.__ele_cell - 1,
                         (point_a_x - self.__ele_xllcorner) // self.__ele_cell)
            point_b_r = (self.__ele_nrows - (point_b_y - self.__ele_yllcorner) // self.__ele_cell - 1,
                         (point_b_x - self.__ele_xllcorner) // self.__ele_cell)

            # get the elevation of start point and end point
            point_a_ele = self.__ele_array[int(point_a_r[0]), int(point_a_r[1])]
            point_b_ele = self.__ele_array[int(point_b_r[0]), int(point_b_r[1])]

            # Naismith's rule
            distance = road_links[link]['length']
            time1 = distance / 5000 * 60
            height = abs(point_a_ele - point_b_ele)
            time2 = height / 10
            time = time1 + time2

            # add weighed edges
            if point_a_ele >= point_b_ele:
                g.add_edge(point_a_id, point_b_id, weight=time1)
                g.add_edge(point_b_id, point_a_id, weight=time)
            else:
                g.add_edge(point_a_id, point_b_id, weight=time)
                g.add_edge(point_b_id, point_a_id, weight=time1)

        # calculate shortest path
        path = nx.dijkstra_path(g, source=self.__start, target=self.__end)
        return path