if __name__ == "__main__":

    import shapely.geometry as sg
    import requests
    from tkinter import *
    from tkinter import messagebox
    import winsound
    import networkx as nx
    import json
    import numpy as np
    import matplotlib.pyplot as plt
    from shapely.geometry import Point, Polygon
    import shapefile
    import rasterio
    import rasterio.mask


    class MyWindow:
        # creating UI to input coordinates
        # Source: Tkinter tutorial https://www.tutorialsteacher.com/python/create-ui-using-tkinter-in-python
        def __init__(self, win):
            # creating labels and positions
            self.lbl0 = Label(win, text='Please insert coordinates (OSGB36) or postal code from the Isle of Wight:')
            self.lbl1 = Label(win, text='EAST or first part of postcode (PO30):')
            self.lbl2 = Label(win, text='NORTH or last part of postcode (1QB):')
            self.lbl3 = Label(win, text='Status:')
            self.lbl4 = Label(win, text='')
            self.t1 = Entry(bd=3)
            self.t2 = Entry(bd=3)
            # creating buttons to calculate and reset input
            self.btn1 = Button(win, text='plot')
            self.btn2 = Button(win, text='clear')
            self.lbl0.place(x=10, y=10)
            self.lbl1.place(x=10, y=50)
            self.t1.place(x=220, y=50)
            self.lbl2.place(x=10, y=100)
            self.t2.place(x=220, y=100)
            self.b1 = Button(win, text='calculate', command=self.calculate)
            self.b2 = Button(win, text='reset')
            self.b2.bind('<Button-1>', self.reset)
            self.b1.place(x=100, y=150)
            self.b2.place(x=200, y=150)
            self.lbl3.place(x=100, y=200)
            self.lbl4.place(x=150, y=200)
            self.e = ""
            self.n = ""

        def calculate(self):
            # creating "calculate" method to return E and N
            es = self.t1.get()
            nt = self.t2.get()
            if es != "" and nt != "":
                while True:
                    try:
                        x = float(es)
                        y = float(nt)
                    except ValueError:
                        # Postcode detector sample: PO30 1QB
                        # SOURCE: https: // api.postcodes.io /
                        self.lbl4.configure(text='Characters in the Input, Checking if Postcode match..')
                        postcode = str(es + nt).replace(" ", "")
                        resp = requests.get('https://api.postcodes.io/postcodes/' +
                                            str(postcode))
                        if resp.status_code != 404:
                            self.lbl4.configure(text='It is a postcode')
                            json_data = json.loads(resp.text)
                            qq = json_data["result"]["eastings"]
                            ww = json_data["result"]["northings"]
                            long = json_data["result"]["longitude"]
                            lat = json_data["result"]["latitude"]
                            self.lbl4.configure(text=str("postcode: \n  E: " + str(qq) +
                                                         "\n  N: " + str(ww) + "\n  Lat: " + str(lat) +
                                                         "\n  Long: " + str(long)))
                            self.e = float(qq)
                            self.n = float(ww)
                            break
                        else:
                            self.lbl4.configure(text="No postcode match, try again.")
                            return
                    else:
                        # check if coords are in range
                        if (425000 < x < 470000) and (75000 < y < 100000):
                            self.lbl4.configure(text="Initialising, please wait...")
                            self.e = x
                            self.n = y
                            break
                        else:
                            self.lbl4.configure(text="Error: Please Enter Coordinates in range\n E425 000,"
                                                     "N75 000-E470 000, "
                                                     "N100 000\n or a postcode of the Isle of Wight")
                            return
            elif es == "" or nt == "":
                self.lbl4.configure(text="Incomplete Coordinates,\n try again...(Press Reset to clear)")
                return
            window.destroy()
            return

        def reset(self, event):
            # creating "reset" method to clear input
            self.t1.delete(0, 'end')
            self.t2.delete(0, 'end')
            self.lbl4.configure(text="")
            winsound.Beep(440, 100)


    class ReadIslandFromShp:
        def __init__(self, shpfilepath):
            self.__filepath = shpfilepath

        def get_island_polygon(self):
            # Read shape file
            sf = shapefile.Reader(self.__filepath)
            feature = sf.shapeRecords()[0]
            first = feature.__geo_interface__
            points = first["geometry"]["coordinates"][3][0]
            # create island vector polygon
            island = Polygon(points)
            return island


    class PointCheck:
        def __init__(self, polygon, point):
            self.__polygon = polygon
            self.__point = point

        def test_point(self):
            # test whether input point is on the island
            if self.__point.touches(self.__polygon) or self.__point.within(self.__polygon):
                status = "Available Location."
            else:
                status = "Error, point outside island boundaries."
                Tk().withdraw()
                messagebox.showerror("ERROR", "The inserted point is outside Isle of Wight Boundaries, try again...")
            return status


    class Elevation:

        def __init__(self, elefilepath, point):
            self.__point = point
            self.__filepath = elefilepath
            with open(self.__filepath, "r") as elefile:
                self.__lines = elefile.readlines()

        def get_ncols(self):
            line0 = self.__lines[0].strip().split(" ")
            return int(line0[1])

        def get_nrows(self):
            line1 = self.__lines[1].strip().split(" ")
            return int(line1[1])

        def get_xllcorner(self):
            line2 = self.__lines[2].strip().split(" ")
            return int(line2[1])

        def get_yllcorner(self):
            line3 = self.__lines[3].strip().split(" ")
            return int(line3[1])

        def get_cellsize(self):
            line4 = self.__lines[4].strip().split(" ")
            return int(line4[1])

        def get_elevation(self):
            self.__eledata = np.zeros((self.get_nrows(), self.get_ncols()))
            row = 0
            for line in self.__lines[5:]:
                eachline = line.strip().split(" ")
                for col in range(0, self.get_ncols()):
                    self.__eledata[row, col] = float(eachline[col])
                row = row + 1
            return self.__eledata

        def get_max_point(self, area):
            features = [area.__geo_interface__]
            with rasterio.open(self.__filepath) as scr:
                out_image, out_transform = rasterio.mask.mask(scr, features, crop=False)
                area_ele = out_image.reshape(out_image.shape[1], out_image.shape[2])
            a = np.where(area_ele == np.max(area_ele))
            shortest=10000
            for m in range(0, len(a[0])):
                xr = a[0][m]
                yr = a[1][m]
                xo = self.get_cellsize() * yr + self.get_cellsize() / 2 + self.get_xllcorner()
                yo = self.get_nrows() * self.get_cellsize() - (
                            self.get_cellsize() * xr + self.get_cellsize() / 2) + self.get_yllcorner()
                xu = self.__point.x
                yu = self.__point.y
                distance = np.sqrt((xu - xo) ** 2 + (yu - yo) ** 2)
                if distance < shortest:
                    shortest = distance
                    hpoint = Point(xo, yo)
            return hpoint

    def main():
        coords1 = sg.Point(input_coords.e, input_coords.n)

        island = ReadIslandFromShp("Material/shape/isle_of_wight.shp").get_island_polygon()
        status = PointCheck(island, coords1).test_point()
        if status == "Error, point outside island boundaries.":
            exit()
        print(status)
        shparea = coords1.buffer(5000).intersection(island)
        highest_point = Elevation("Material/elevation/SZ.asc", coords1).get_max_point(shparea)
        print(highest_point)

    window = Tk()
    input_coords = MyWindow(window)
    # creating window using the MYWindow class
    window.title('FLOOD EMERGENCY PLANNING')
    window.geometry("400x300+10+10")
    window.mainloop()
    main()
